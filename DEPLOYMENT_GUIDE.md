# Calndr Backend Deployment Guide

## Overview
This guide provides step-by-step instructions for deploying the Calndr Backend, which has been containerized and configured for AWS ECS deployment with full CI/CD pipeline support.

## Prerequisites

### Local Development
- Docker and Docker Compose installed
- Python 3.11+ (for local testing without Docker)
- Git
- Text editor/IDE

### AWS Deployment
- AWS CLI configured with appropriate credentials
- Terraform installed (v1.0+)
- GitHub repository with Actions enabled
- Domain name (optional, for custom domains)

## Local Development Setup

### 1. Clone and Setup Environment
```bash
git clone <your-repo-url>
cd calndr-backend-refactor
cp .env.example .env
```

### 2. Configure Environment Variables
Edit the `.env` file with your specific values:

**Required for local development:**
```bash
# Database (using Docker Compose defaults)
DB_USER=calndr_user
DB_PASSWORD=calndr_password
DB_HOST=postgres
DB_PORT=5432
DB_NAME=calndr_dev

# Redis (using Docker Compose defaults)
REDIS_HOST=redis
REDIS_PORT=6379

# Security (change for production)
SECRET_KEY=your_secure_secret_key_here
```

**Optional for local development:**
- AWS credentials (for S3, SNS features)
- Google Places API key
- Apple/Google Sign-In credentials
- SMTP configuration

### 3. Start Local Development Environment
```bash
# Start all services
docker-compose up -d

# View logs
docker-compose logs -f

# Stop services
docker-compose down

# Stop and remove volumes (clean slate)
docker-compose down --volumes
```

### 4. Access Local Services
- **API**: http://localhost:8000
- **API Documentation**: http://localhost:8000/docs
- **Health Check**: http://localhost:8000/health
- **Nginx (Load Balancer)**: http://localhost:80
- **PostgreSQL**: localhost:5432
- **Redis**: localhost:6379

## AWS Infrastructure Deployment

### 1. Prepare AWS Environment
```bash
# Configure AWS CLI
aws configure

# Verify access
aws sts get-caller-identity
```

### 2. Initialize Terraform
```bash
cd terraform

# Initialize Terraform
terraform init

# Review planned changes
terraform plan

# Apply infrastructure
terraform apply
```

### 3. Configure GitHub Actions Secrets
Add these secrets to your GitHub repository:

**Required AWS Secrets:**
- `AWS_ACCOUNT_ID`: Your AWS account ID
- `AWS_REGION`: Your deployment region (e.g., us-east-1)
- `ECR_REPOSITORY`: ECR repository name from Terraform output

**Application Secrets:**
- `SECRET_KEY`: Secure secret key for JWT tokens
- `DB_PASSWORD`: Database password (auto-generated by Terraform)
- `REDIS_AUTH_TOKEN`: Redis auth token (auto-generated by Terraform)

**Optional Secrets:**
- `AWS_S3_BUCKET_NAME`: S3 bucket for file storage
- `GOOGLE_PLACES_API_KEY`: Google Places API key
- `APPLE_CLIENT_ID`, `APPLE_TEAM_ID`, etc.: Apple Sign-In configuration
- `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET`: Google Sign-In configuration
- `SMTP_*`: Email configuration

### 4. Deploy Using Scripts
```bash
# Initialize infrastructure
./deploy-containerized.sh init-infrastructure

# Deploy to staging
./deploy-containerized.sh deploy-staging

# Deploy to production
./deploy-containerized.sh deploy-production

# Check deployment status
./deploy-containerized.sh status

# View logs
./deploy-containerized.sh logs
```

## CI/CD Pipeline

### Automatic Deployments
The GitHub Actions pipeline automatically:

1. **On Push to `develop`**: Deploys to staging
2. **On Push to `main`**: Deploys to production
3. **Security Scanning**: Runs Trivy vulnerability scans
4. **Health Checks**: Verifies deployment success

### Manual Deployments
You can also trigger deployments manually:

```bash
# Build and push image manually
docker build -t calndr-backend .
docker tag calndr-backend:latest <AWS_ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/calndr-backend:latest
aws ecr get-login-password --region <REGION> | docker login --username AWS --password-stdin <AWS_ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com
docker push <AWS_ACCOUNT_ID>.dkr.ecr.<REGION>.amazonaws.com/calndr-backend:latest

# Update ECS service
aws ecs update-service --cluster calndr-production --service calndr-backend-service --force-new-deployment
```

## Environment Configuration

### Development Environment
- **Purpose**: Local development and testing
- **Database**: Local PostgreSQL in Docker
- **Redis**: Local Redis in Docker
- **Scaling**: Single instance
- **Monitoring**: Docker Compose logs

### Staging Environment
- **Purpose**: Pre-production testing
- **Database**: AWS RDS PostgreSQL
- **Redis**: AWS ElastiCache
- **Scaling**: 1-2 ECS tasks
- **Monitoring**: CloudWatch logs and metrics
- **Domain**: staging.yourdomain.com (if configured)

### Production Environment
- **Purpose**: Live application
- **Database**: AWS RDS PostgreSQL with read replica
- **Redis**: AWS ElastiCache with clustering
- **Scaling**: 2-10 ECS tasks (auto-scaling enabled)
- **Monitoring**: Full CloudWatch monitoring + alerts
- **Domain**: yourdomain.com (if configured)

## Database Management

### Local Development
```bash
# Connect to local database
docker-compose exec postgres psql -U calndr_user -d calndr_dev

# Run database migrations (when implemented)
docker-compose exec app python -m alembic upgrade head
```

### Production Database
```bash
# Connect via bastion host (if configured)
aws ssm start-session --target <bastion-instance-id>

# Or connect directly (if security groups allow)
psql -h <rds-endpoint> -U <username> -d <database>
```

## Monitoring and Troubleshooting

### Health Checks
- **Application**: `GET /health`
- **Database**: `GET /db-info`
- **Cache**: `GET /cache-status`

### Logs
```bash
# Local logs
docker-compose logs -f app

# AWS logs
aws logs tail /aws/ecs/calndr-backend --follow

# Or using deployment script
./deploy-containerized.sh logs
```

### Common Issues

**Container Won't Start:**
1. Check environment variables in `.env`
2. Verify database connectivity
3. Check Docker build logs

**Database Connection Issues:**
1. Verify database credentials
2. Check security group rules
3. Confirm RDS instance is running

**ECS Deployment Fails:**
1. Check CloudWatch logs
2. Verify ECR image exists
3. Check ECS service events
4. Validate IAM permissions

### Scaling

**Manual Scaling:**
```bash
# Scale ECS service
aws ecs update-service --cluster calndr-production --service calndr-backend-service --desired-count 5
```

**Auto-scaling:**
- CPU utilization target: 70%
- Memory utilization target: 80%
- Min tasks: 2, Max tasks: 10

## Security Considerations

### Environment Variables
- Never commit `.env` files to git
- Use AWS Systems Manager Parameter Store for production secrets
- Rotate secrets regularly

### Network Security
- ECS tasks run in private subnets
- Database and Redis in dedicated subnets
- Security groups restrict access between components
- ALB handles SSL termination

### Container Security
- Multi-stage Docker builds minimize attack surface
- Non-root user in containers
- Regular vulnerability scanning with Trivy
- Base images updated regularly

## Backup and Recovery

### Database Backups
- Automated daily snapshots via RDS
- Point-in-time recovery available
- Cross-region backup replication (if configured)

### Application Data
- S3 bucket for file storage (if configured)
- Redis data is cache-only (no persistence required)

## Cost Optimization

### Development
- Use t3.micro instances
- Stop services when not in use
- Single AZ deployment

### Production
- Use reserved instances for baseline capacity
- Auto-scaling for variable load
- Multi-AZ for high availability
- Consider spot instances for non-critical workloads

## Support and Maintenance

### Regular Tasks
1. Monitor CloudWatch dashboards
2. Review and act on CloudWatch alarms
3. Update container images regularly
4. Rotate secrets quarterly
5. Review and update security groups

### Emergency Procedures
1. **Service Down**: Check ECS service status and CloudWatch logs
2. **Database Issues**: Check RDS status and connectivity
3. **High Load**: Manually scale ECS service if needed
4. **Security Incident**: Review CloudTrail logs and rotate credentials

## Getting Help

- **Application Logs**: CloudWatch Logs
- **Infrastructure**: CloudWatch Metrics and Alarms
- **Deployment Issues**: GitHub Actions logs
- **Database**: RDS Performance Insights

For additional support, check the application documentation and CloudWatch dashboards for detailed metrics and logs. 